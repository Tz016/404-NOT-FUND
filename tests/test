// tests/test.js
import request from 'supertest';
import sinon from 'sinon';
import { expect } from 'chai';

// *** CRITICAL: Adjust imports to point to the backend folder ***
import watchlistController from '../backend/controllers/watchlistController.js';
import WatchlistModel from '../backend/models/watchlistModel.js';
import transactionModel from '../backend/models/transactionModel.js'; // Still needed if controller uses it
import yahooFinance from 'yahoo-finance2';

import mainApp from '../backend/app.js'; // This is the Express app instance

const app = mainApp; // 'app' directly refers to the configured Express app

describe('Watchlist API Tests', () => {
  let sandbox;

  beforeEach(() => {
    sandbox = sinon.createSandbox();
  });

  afterEach(() => {
    sandbox.restore();
  });

  // --- POST /watchlist/add Tests ---
  describe('POST /watchlist/add', () => {
    it('should add a new watchlist item successfully', async () => {
      const mockTicker = 'AAPL';
      const mockAccountId = 1;
      const mockQuote = { regularMarketPrice: 211.27}; 
      const mockWatchId = 123;

      sandbox.stub(yahooFinance, 'quote').resolves(mockQuote);
      sandbox.stub(WatchlistModel, 'findOne').resolves(null);
      sandbox.stub(WatchlistModel, 'create').resolves(mockWatchId);

      const res = await request(app)
        .post('/watchlist/add')
        .send({ ticker: mockTicker, accountId: mockAccountId });

      expect(res.statusCode).to.equal(201);
      expect(res.body.success).to.be.true;
      expect(res.body.data).to.have.property('watch_id', mockWatchId);
      expect(res.body.data).to.have.property('ticker', mockTicker);
      expect(res.body.data).to.have.property('account_id', mockAccountId);
      expect(res.body.data).to.have.property('last_price', mockQuote.regularMarketPrice);
      expect(res.body.data).to.have.property('symbol', mockTicker);
    });

    it('should return 400 if stock already exists in the watchlist', async () => {
      const mockTicker = 'GOOG';
      const mockAccountId = 1;
      const existingItem = { watch_id: 456, ticker: mockTicker, account_id: mockAccountId };

      sandbox.stub(WatchlistModel, 'findOne').resolves(existingItem);

      const res = await request(app)
        .post('/watchlist/add')
        .send({ ticker: mockTicker, accountId: mockAccountId });

      expect(res.statusCode).to.equal(400);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('Stock already exists in the watchlist');
    });

    it('should return 500 if an internal server error occurs during add', async () => {
      const mockTicker = 'AMZN';
      const mockAccountId = 1;

      sandbox.stub(WatchlistModel, 'findOne').throws(new Error('Database error during findOne'));

      const res = await request(app)
        .post('/watchlist/add')
        .send({ ticker: mockTicker, accountId: mockAccountId });

      expect(res.statusCode).to.equal(500);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('Database error during findOne');
    });
  });

  // --- GET /watchlist/:accountId Tests ---
  describe('GET /watchlist/:accountId', () => {
    it('should return watchlist items for a given accountId', async () => {
      const mockAccountId = 1;
      const mockWatchlistItems = [
        { watch_id: 1, account_id: 1, ticker: 'AAPL', last_price: 150.00 },
        { watch_id: 2, account_id: 1, ticker: 'MSFT', last_price: 300.50 }
      ];

      sandbox.stub(WatchlistModel, 'findByAccountId').resolves(mockWatchlistItems);

      const res = await request(app)
        .get(`/watchlist/${mockAccountId}`);

      expect(res.statusCode).to.equal(200);
      expect(res.body).to.deep.equal(mockWatchlistItems);
    });

    it('should return an empty array if no watchlist items found for accountId', async () => {
      const mockAccountId = 99;

      sandbox.stub(WatchlistModel, 'findByAccountId').resolves([]);

      const res = await request(app)
        .get(`/watchlist/${mockAccountId}`);

      expect(res.statusCode).to.equal(200);
      expect(res.body).to.deep.equal([]);
    });

    it('should return 500 if an internal server error occurs during get', async () => {
      const mockAccountId = 1;

      sandbox.stub(WatchlistModel, 'findByAccountId').throws(new Error('DB error on find'));

      const res = await request(app)
        .get(`/watchlist/${mockAccountId}`);

      expect(res.statusCode).to.equal(500);
      expect(res.body).to.have.property('error', 'DB error on find');
    });
  });

  // --- PUT /watchlist/delete Tests ---
  describe('PUT /watchlist/delete', () => {
    it('should delete a watchlist item successfully', async () => {
      const mockWatchId = 789;

      sandbox.stub(WatchlistModel, 'delete').resolves(1);

      const res = await request(app)
        .put('/watchlist/delete')
        .send({ watchId: mockWatchId });

      expect(res.statusCode).to.equal(200);
      expect(res.body.success).to.be.true;
      expect(res.body.data).to.have.property('watchId', mockWatchId);
    });

    it('should return 404 if watchlist item is not found for deletion', async () => {
      const mockWatchId = 999;

      sandbox.stub(WatchlistModel, 'delete').resolves(0);

      const res = await request(app)
        .put('/watchlist/delete')
        .send({ watchId: mockWatchId });

      expect(res.statusCode).to.equal(404);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('Watchlist item not found');
    });

    it('should return 400 if watchId is missing for deletion', async () => {
      const res = await request(app)
        .put('/watchlist/delete')
        .send({});

      expect(res.statusCode).to.equal(400);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('watchId is required');
    });

    it('should return 500 if an internal server error occurs during deletion', async () => {
      const mockWatchId = 111;

      sandbox.stub(WatchlistModel, 'delete').throws(new Error('DB connection error'));

      const res = await request(app)
        .put('/watchlist/delete')
        .send({ watchId: mockWatchId });

      expect(res.statusCode).to.equal(500);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('DB connection error');
    });
  });
  // PUT /watchlist/update/addTransaction Tests
  // tests/test (replace the existing PUT /watchlist/update/addTransaction block)

  // --- PUT /watchlist/update/addTransaction Tests ---
  describe('PUT /watchlist/update/addTransaction', () => {
    // These values will be sent in the request body as per the controller's design
    const mockTicker = 'TSLA';
    const mockShares = 10;
    const mockDate = '2025-07-30';
    const mockLastPrice = 200.00; 
    
    // Calculations as per the controller's logic (for verification in tests)
    const calculatedAcShare = mockLastPrice / mockShares; 
    const calculatedTotalCost = mockLastPrice * calculatedAcShare; // Based on controller: last_price * ac_share
    const calculatedMarketValue = mockLastPrice * mockShares; // Based on controller: last_price * shares

    beforeEach(() => {
      // Stub transactionModel.create. The controller does NOT await it, but we can still assert it's called.
      sandbox.stub(transactionModel, 'create').resolves(1); // Simulate successful transaction creation
    });

    it('should successfully add a transaction and return its data', async () => {
      const res = await request(app)
        .put('/watchlist/update/addTransaction')
        .send({
          ticker: mockTicker,
          shares: mockShares,
          date: mockDate,
          last_price: mockLastPrice // This is now an input from the request body
        });

      expect(res.statusCode).to.equal(200);
      expect(res.body.success).to.be.true;
      expect(res.body.data).to.have.property('transactionData');
      
      const transactionDataResponse = res.body.data.transactionData;

      // Assert the fields as they are structured in the controller's transactionData object
      expect(transactionDataResponse).to.have.property('date', mockDate);
      expect(transactionDataResponse).to.have.property('symbol', mockTicker);
      expect(transactionDataResponse).to.have.property('shares', mockShares);
      expect(transactionDataResponse).to.have.property('cost_per_share', mockLastPrice);
      expect(transactionDataResponse).to.have.property('total_cost', calculatedTotalCost);
      expect(transactionDataResponse).to.have.property('market_value', calculatedMarketValue);
      // 'Status' and 'ac_share' are calculated but NOT added to the transactionData object in the controller's response, so we don't assert them here.

      // Verify that transactionModel.create was called once
      expect(transactionModel.create.calledOnce).to.be.true;
      
      // Verify the arguments passed to transactionModel.create
      const createdTransactionArgs = transactionModel.create.getCall(0).args[0];
      expect(createdTransactionArgs.date).to.equal(mockDate);
      expect(createdTransactionArgs.symbol).to.equal(mockTicker);
      expect(createdTransactionArgs.shares).to.equal(mockShares);
      expect(createdTransactionArgs.cost_per_share).to.equal(mockLastPrice);
      expect(createdTransactionArgs.total_cost).to.equal(calculatedTotalCost);
      expect(createdTransactionArgs.market_value).to.equal(calculatedMarketValue);
      // The `Status` variable in the controller is set to 'Active', but it's not included in `transactionData` for `create` call.
      // If it should be in the DB, add it to the `transactionData` object in the controller.
    });

    // Test for when transactionModel.create fails
    it('should return 500 if an internal server error occurs during transaction creation', async () => {
      // Override the default stub to simulate a database error
      transactionModel.create.restore(); // Restore to allow new stub behavior
      sandbox.stub(transactionModel, 'create').throws(new Error('Database write failed'));

      const res = await request(app)
        .put('/watchlist/update/addTransaction')
        .send({
          ticker: mockTicker,
          shares: mockShares,
          date: mockDate,
          last_price: mockLastPrice
        });

      expect(res.statusCode).to.equal(500);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('Something broke!'); // Assuming global error handler catches and returns this
    });
  });
    
});