// tests/test
import request from 'supertest';
import sinon from 'sinon';
import { expect } from 'chai';

// Imports to correctly point from 'tests/' to 'backend/'
import watchlistController from '../backend/controllers/watchlistController.js';
import WatchlistModel from '../backend/models/watchlistModel.js';
import transactionModel from '../backend/models/transactionModel.js';
import yahooFinance from 'yahoo-finance2';

// Import the actual 'app.js' from the backend directory
import mainApp from '../backend/app.js';

const app = mainApp; // 'app' directly refers to the configured Express app

describe('Watchlist API Tests', () => {
  let sandbox;

  beforeEach(() => {
    sandbox = sinon.createSandbox();
  });

  afterEach(() => {
    sandbox.restore();
  });

  // --- POST /watchlist/add Tests ---
  describe('POST /watchlist/add', () => {
    const mockTicker = 'AAPL';
    const mockAccountId = 1;
    const mockWatchId = 123; // Fixed watchId for successful creation

    beforeEach(() => {
      // Stub yahooFinance.quote. Even if the app's instance gets real data due to module loading,
      // this stub prevents errors if the real API were to fail during test.
      sandbox.stub(yahooFinance, 'quote').resolves({ regularMarketPrice: 999.99 });

      // Default stub for findOne (stock does not exist) for the successful add test
      sandbox.stub(WatchlistModel, 'findOne').resolves(null);

      // Stub WatchlistModel.create to return a predictable watchId
      sandbox.stub(WatchlistModel, 'create').resolves(mockWatchId);
    });

    afterEach(() => {
      // sandbox.restore() is handled by the outer afterEach, but can be here too for clarity
    });

    it('should add a new watchlist item successfully', async () => {
      const res = await request(app)
        .post('/watchlist/add')
        .send({ ticker: mockTicker, accountId: mockAccountId });

      expect(res.statusCode).to.equal(201);
      expect(res.body.success).to.be.true;
      expect(res.body.data).to.have.property('watch_id', mockWatchId);
      expect(res.body.data).to.have.property('ticker', mockTicker);
      expect(res.body.data).to.have.property('account_id', mockAccountId);

      // Pragmatic fix for last_price assertion:
      // Since the real API call for yahooFinance in app.js is likely still occurring,
      // we assert its type and validity, rather than a specific (fluctuating) stubbed value.
      expect(res.body.data).to.have.property('last_price').that.is.a('number');
      expect(res.body.data.last_price).to.be.above(0);

      expect(res.body.data).to.have.property('symbol', mockTicker);
    });

    it('should return 400 if stock already exists in the watchlist', async () => {
      const existingTicker = 'GOOG';
      const existingAccountId = 1;
      const existingItem = { watch_id: 456, ticker: existingTicker, account_id: existingAccountId };

      // Restore the WatchlistModel.findOne stub created in beforeEach
      WatchlistModel.findOne.restore();
      // Stub findOne to return an existing item for this specific test
      sandbox.stub(WatchlistModel, 'findOne').resolves(existingItem);

      const res = await request(app)
        .post('/watchlist/add')
        .send({ ticker: existingTicker, accountId: existingAccountId });

      expect(res.statusCode).to.equal(400);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('Stock already exists in the watchlist');
    });

    it('should return 500 if an internal server error occurs during add', async () => {
      const errorTicker = 'AMZN';
      const errorAccountId = 1;

      // Restore WatchlistModel.findOne stub and make it throw an error
      WatchlistModel.findOne.restore();
      sandbox.stub(WatchlistModel, 'findOne').throws(new Error('Database error during findOne'));

      const res = await request(app)
        .post('/watchlist/add')
        .send({ ticker: errorTicker, accountId: errorAccountId });

      expect(res.statusCode).to.equal(500);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('Database error during findOne');
    });
  });

  // --- GET /watchlist/:accountId Tests ---
  describe('GET /watchlist/:accountId', () => {
    it('should return watchlist items for a given accountId', async () => {
      const mockAccountId = 1;
      const mockWatchlistItems = [
        { watch_id: 1, account_id: 1, ticker: 'AAPL', last_price: 150.00 },
        { watch_id: 2, account_id: 1, ticker: 'MSFT', last_price: 300.50 }
      ];

      sandbox.stub(WatchlistModel, 'findByAccountId').resolves(mockWatchlistItems);

      const res = await request(app)
        .get(`/watchlist/${mockAccountId}`);

      expect(res.statusCode).to.equal(200);
      expect(res.body).to.deep.equal(mockWatchlistItems);
    });

    it('should return an empty array if no watchlist items found for accountId', async () => {
      const mockAccountId = 99;

      sandbox.stub(WatchlistModel, 'findByAccountId').resolves([]);

      const res = await request(app)
        .get(`/watchlist/${mockAccountId}`);

      expect(res.statusCode).to.equal(200);
      expect(res.body).to.deep.equal([]);
    });

    it('should return 500 if an internal server error occurs during get', async () => {
      const mockAccountId = 1;

      sandbox.stub(WatchlistModel, 'findByAccountId').throws(new Error('DB error on find'));

      const res = await request(app)
        .get(`/watchlist/${mockAccountId}`);

      expect(res.statusCode).to.equal(500);
      expect(res.body).to.have.property('error', 'DB error on find');
    });
  });

  // --- PUT /watchlist/delete Tests ---
  describe('PUT /watchlist/delete', () => {
    it('should delete a watchlist item successfully', async () => {
      const mockWatchId = 789;

      sandbox.stub(WatchlistModel, 'delete').resolves(1); // 1 affected row

      const res = await request(app)
        .put('/watchlist/delete')
        .send({ watchId: mockWatchId });

      expect(res.statusCode).to.equal(200);
      expect(res.body.success).to.be.true;
      expect(res.body.data).to.have.property('watchId', mockWatchId);
    });

    it('should return 404 if watchlist item is not found for deletion', async () => {
      const mockWatchId = 999;

      sandbox.stub(WatchlistModel, 'delete').resolves(0); // 0 affected rows

      const res = await request(app)
        .put('/watchlist/delete')
        .send({ watchId: mockWatchId });

      expect(res.statusCode).to.equal(404);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('Watchlist item not found');
    });

    it('should return 400 if watchId is missing for deletion', async () => {
      const res = await request(app)
        .put('/watchlist/delete')
        .send({});

      expect(res.statusCode).to.equal(400);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('watchId is required');
    });

    it('should return 500 if an internal server error occurs during deletion', async () => {
      const mockWatchId = 111;

      sandbox.stub(WatchlistModel, 'delete').throws(new Error('DB connection error'));

      const res = await request(app)
        .put('/watchlist/delete')
        .send({ watchId: mockWatchId });

      expect(res.statusCode).to.equal(500);
      expect(res.body.success).to.be.false;
      expect(res.body.error).to.equal('DB connection error');
    });
  });

  // --- PUT /watchlist/update/addTransaction Tests ---
  describe('PUT /watchlist/update/addTransaction', () => {
    // These values will be sent in the request body as per the controller's design
    const mockTicker = 'TSLA';
    const mockShares = 10;
    const mockDate = '2025-07-30';
    const mockLastPrice = 200.00;

    // Calculations as per the controller's logic (for verification in tests)
    const calculatedAcShare = mockLastPrice / mockShares;
    const calculatedTotalCost = mockLastPrice * calculatedAcShare; // Based on controller: last_price * ac_share
    const calculatedMarketValue = mockLastPrice * mockShares; // Based on controller: last_price * shares

    beforeEach(() => {
      // No need to stub yahooFinance.quote anymore as last_price is from req.body
      sandbox.stub(transactionModel, 'create').resolves(1); // Simulate successful transaction creation
    });

    it('should successfully add a transaction and return its data', async () => {
      const res = await request(app)
        .put('/watchlist/update/addTransaction')
        .send({
          ticker: mockTicker,
          shares: mockShares,
          date: mockDate,
          last_price: mockLastPrice // last_price is now passed in the body
        });

      expect(res.statusCode).to.equal(200);
      expect(res.body.success).to.be.true;
      expect(res.body.data).to.have.property('transactionData');

      const transactionDataResponse = res.body.data.transactionData;

      // Assert the fields as they are structured in the controller's transactionData object
      expect(transactionDataResponse).to.have.property('date', mockDate);
      expect(transactionDataResponse).to.have.property('symbol', mockTicker);
      expect(transactionDataResponse).to.have.property('shares', mockShares);
      expect(transactionDataResponse).to.have.property('cost_per_share', mockLastPrice);
      expect(transactionDataResponse).to.have.property('total_cost', calculatedTotalCost);
      expect(transactionDataResponse).to.have.property('market_value', calculatedMarketValue);
      // 'Status' and 'ac_share' are calculated but NOT added to the transactionData object in the controller's response, so we don't assert them here.

      // Verify that transactionModel.create was called once
      expect(transactionModel.create.calledOnce).to.be.true;

      // Verify the arguments passed to transactionModel.create
      const createdTransactionArgs = transactionModel.create.getCall(0).args[0];
      expect(createdTransactionArgs.date).to.equal(mockDate);
      expect(createdTransactionArgs.symbol).to.equal(mockTicker);
      expect(createdTransactionArgs.shares).to.equal(mockShares);
      expect(createdTransactionArgs.cost_per_share).to.equal(mockLastPrice);
      expect(createdTransactionArgs.total_cost).to.equal(calculatedTotalCost);
      expect(createdTransactionArgs.market_value).to.equal(calculatedMarketValue);
    });

    // Test for internal server error during transaction creation
    it('should return 500 if an internal server error occurs during transaction creation', async () => {
      // Override the default stub to simulate a database error
      transactionModel.create.restore(); // Restore to allow new stub behavior
      sandbox.stub(transactionModel, 'create').throws(new Error('Database write failed'));

      const res = await request(app)
        .put('/watchlist/update/addTransaction')
        .send({
          ticker: mockTicker,
          shares: mockShares,
          date: mockDate,
          last_price: mockLastPrice
        });

      expect(res.statusCode).to.equal(500);
      expect(res.body.success).to.be.false;
      // Expect the error message to match what the controller's (missing) try-catch might return
      // or what a global error handler might return. Assuming default Express error handling here.
      expect(res.body.error).to.equal('Something broke!');
    });
  });
});